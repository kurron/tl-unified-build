// common logic applied via init.gradle scripts
println 'common.gradle'

allprojects {
    buildscript {
        repositories {
            mavenLocal()
        }
        dependencies {
            classpath group: 'org.kurron', name: 'unified-build', version: '0.1-SNAPSHOT'
        }
    }

    repositories {
        mavenCentral()
        mavenLocal()
    }

    configurations {
        sourceArchives {
            description = 'Artifact that contains the source code of the dependencies.'
        }
    }

    ext.junitVersion  = '4.10'
    ext.hamcrestVersion  = '1.3'
    ext.groovyVersion  = '2.1.0'
    ext.spockVersion  = '0.7-groovy-2.0'

    task wrapper(type: Wrapper) {
        gradleVersion = '1.4'
        description = 'Generate the Gradle wrapper scripts'
    }


    afterProject { project ->
        println 'after ' + project.name
        if ( project.plugins.hasPlugin( JavaPlugin ) )
        {
            println 'Java plugin detected!'
            logger.quiet 'Configuring compiler options'
            project.tasks.getByName( 'compileJava' ).options*.compilerArgs = ['-Xlint:deprecation','-encoding', 'UTF-8']
            project.tasks.getByName( 'compileTestJava' ).options*.compilerArgs = ['-Xlint:deprecation','-encoding', 'UTF-8']

            logger.quiet 'Configuring unit testing options'
            project.tasks.getByName( 'test' ).scanForTestClasses = false
            project.tasks.getByName( 'test' ).includes = ['**/*UnitTest.class']
            project.tasks.getByName( 'test' ).excludes = ['**/AbstractCardUnitTest.class','**/AbstractUnitTest.class']
            // needed for Java 7 and Cobertura combination
            project.tasks.getByName( 'test' ).jvmArgs "-XX:-UseSplitVerifier"
            project.tasks.getByName( 'test' ).maxParallelForks = Runtime.runtime.availableProcessors()

            // we use the "module" form so that transitive dependencies aren't pulled down and we fully control the versions
            project.dependencies  {
                testCompile module( "junit:junit-dep:${junitVersion}" )
                testCompile module( "org.hamcrest:hamcrest-all:${hamcrestVersion}" )
                testCompile module( "org.codehaus.groovy:groovy-all:${groovyVersion}:indy" )
                testCompile module( "org.spockframework:spock-core:${spockVersion}" )

                sourceArchives module( "junit:junit-dep:${junitVersion}:sources" )
                sourceArchives module( "org.hamcrest:hamcrest-all:${hamcrestVersion}:sources" )
                sourceArchives module( "org.spockframework:spock-core:${spockVersion}:sources" )
            }

            task collectJars(type: Copy) {
                into "$buildDir/dependencies"
                from( [configurations.testRuntime,configurations.sourceArchives] )
                doFirst { logger.quiet "Copying dependencies to $buildDir/dependencies" }
            }
            project.defaultTasks = ['collectJars'] + project.defaultTasks

            logger.quiet 'Applying jdepend plug-in'
            project.plugins.apply( 'jdepend' )
            project.jdependMain.enabled = true
            project.jdependTest.enabled = true
            project.properties['jdepend'].ignoreFailures = false
            project.properties['jdepend'].sourceSets = [sourceSets.main,sourceSets.test]

            logger.quiet 'Applying checkstyle plug-in'
            project.plugins.apply( 'checkstyle' )
            project.properties['checkstyle'].ignoreFailures = false
            project.checkstyleMain.enabled = true
            project.checkstyleTest.enabled = false
            new File( "$buildDir" ).mkdirs()
            ant.get( src: 'https://raw.github.com/kurron/tl-unified-build/master/config/checkstyle/checkstyle.xml',
                    dest: "$buildDir/checkstyle.xml",
                    verbose: true,
                    usetimestamp: true,
                    maxtime: 2 )
            checkstyle.configFile = file("$buildDir/checkstyle.xml")
            checkstyle.configProperties = [suppressionDirectory: projectDir.path ]

            ext.sharedManifest = manifest {
                attributes( "Implementation-Title": project.name, "Implementation-Version": project.version )
            }
            task sourcesJar(type: Jar, dependsOn: classes) {
                classifier = 'sources'
                from sourceSets.main.allSource
                exclude('**/*.properties')
                manifest = project.manifest {
                    from sharedManifest
                }
            }

            task testSourcesJar(type: Jar, dependsOn: testClasses) {
                classifier = 'test-sources'
                from sourceSets.test.allSource
                exclude('**/*.properties')
                manifest = project.manifest {
                    from sharedManifest
                }
            }

            task testBinariesJar(type: Jar, dependsOn: testClasses) {
                classifier = 'test'
                from sourceSets.test.output
                manifest = project.manifest {
                    from sharedManifest
                }
            }

            task javadocJar(type: Jar, dependsOn: javadoc) {
                classifier = 'api'
                from project.docsDir.path + '/javadoc'
                manifest = project.manifest {
                    from sharedManifest
                }
            }

            artifacts {
                archives sourcesJar
                archives testSourcesJar
                archives testBinariesJar
                archives javadocJar
            }
        }

        if ( !project.plugins.hasPlugin( ProjectReportsPlugin ) )
        {
            logger.quiet 'Applying project-report plug-in'
            project.plugins.apply( 'project-report' )
            project.dependencyReport.enabled = true
            project.propertyReport.enabled = true
            project.taskReport.enabled = true
            // most useful if the reports are generated prior to other tasks running
            project.defaultTasks = ['projectReport'] + project.defaultTasks
        }
    }
}
